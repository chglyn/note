typef null => object
typeof NaN => number
true => 1
false => 0
***************************************
函数声明整体提升
变量 声明提升
imply global暗示全局变量
即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。
	a=10  ==> window.a=10;
一切声明的全局变量，全是window的属性
	var a=1; ==>window.a=1;
***************************************
预编译发生在函数执行前一刻
//预编译
创建AO对象  Activetion Object
找形参和变量声明，将变量和形参名作为AO属性名，值为：undefined
将实参值和形参统一
在函数体里面找函数声明，值赋予函数体
***********************函数***********************
function fn(a) {
	console.log(a); //function a() {}
	
	var a=123;
	console.log(a) //123
	
	function a() {}
	console.log(a); //123
	
	var b=function() {}
	console.log(b); //function b() {}
	
	function d() {}
}
fn(1);

global object ===window === GO

//解析
function a() {
   function b() {
      function c() {}
      c();
   }
   b();
}
a();

a defined a.[[scope]] --> 0:GO
a doing a.[[scope]] --> 0:aAO
		   -->  1:GO
b defined b.[[scope]] --> 0:aAO
		   -->  1:GO		  
b doing b.[[scope]] --> 0:bAO
		   -->  1:aAO
		   -->  2:GO
c defined c.[[scope]] --> 0:bAO
		   -->  1:aAO
		   -->  2:GO	
c doing a.[[scope]] 0 -->cAO
		    1 --> bAO
		    2 --> cAO
		    3 --> GO
		
//闭包： （内部的函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。） 里面的函数比外面的函数活着还长 ^-^
function a() {
   function b() {
	var bbb=234;
	console.log(aaa);
   }
   var aaa=123;
   return b;
}
var glob=100;
var demo=a();
demo(); //123
***************************************
function a() {
  var num = 100;
  function b() {
	num ++;
	console.log(num);
  }
  return b;
}
var demo = a();
demo(); //101
demo(); //102
***************************************
function test() {
	var arr = [];
	for(var i = 0; i < 10; i++) {
		arr[i] = function() {
			console.log(i); // 打印10个10
		}
	}
	return arr;
}

var myArr = test();
for (var j = 0; j < 10; j++) {
	myArr[j]();
}
上面函数修改如下
function test() {
	var arr = [];
	for(var i = 0; i < 10; i++) {
		(function(j) {
			arr[j] = function() {
				console.log(j); //打印10个10
			}
		}(i))
	}
	return arr;
}

var demo = a;
function test() {
	var abc = 123;
	function a() {
		console.log(abc); //123
	}
	demo = a;
}
test();
demo();
***************************************
	a = 100;
	function demo(e) {
		function e() {}
		arguments[0] = 2;
		console.log(e); //2
		if(a) { //if里面不能放函数，之前可以放函数
			var b = 123;
			function c() {}
		}
		var c;
		a = 10;
		var a;
		console.log(b); //undefined
		f = 123;
		console.log(c); // undefined 或者 function c() {}
		console.log(a); //10
	}
	var a;
	demo(1);
	console.log(a); //100
	console.log(f); //123
***************************************
//立即执行函数 -> 执行完立即释放
	(function(a, b, c) { //形参
		console.log(a+b+c);
	}(1, 2, 3)); //实参

	var num = (function(a, b, c) { 
		 var d = a + b + c;
		 return d; //6
	}(1, 2, 3));

******只有表达式才能被执行符号执行******
	var test = function() {
		console.log('a'); //a
	}();
 
 	第二次执行 test(); //undefined;
*****************************************
 function test(a, b) {
 	console.log(a+b); // 什么也不输出
 }(1, 2);
 ***************************************
 （正负非）+|-|! function test() {
	console.log('a') //a
 }();
***************************************
逗号运算符：
a = (1 - 1, 1 + 1); //2 计算前面结果，再计算后面运算结果 => 返回后面结果

	var x = 1;
	if(function f() {}) { // 表达式, 再执行
		x += typeof f;
	}
	console.log(x); //1undefined
***********************对象************************
名词：函数引用、 函数执行()

对象创建方法： 
	字面量、
	var obj = {}
	构造函数（1:系统自带、2:自定义） 特点：大驼峰命名
	1:
	var obj = new Object{}
	2:
	function Person(color) {
		/*隐式
		var this = {
			name:'',
			height:''
			...
		}; 
		AO:{ this:{ name:... } }
		*/
		this.name = 'BMW';
		this.height = '1400';
		this.width = '4900';
		this.color = color;
		//显示 return {}; 返回空对象
		//显示 return 123; 返回这个对象里面的属性值 
		/*
		隐式 return this;
		*/
	}
	var person = new Person();
	内部原理：
		在函数体最前面隐式的加上this = {};
		执行this.xxx = xxx;
		隐式的返回this;
	
	Person.prototype.anme = 'sunny';
	function Person() {
		/*
		var this = {
			__proto__ : Person.prototype
		}
		*/
	}
	var person = new Person();
	
*****************包装类**************************
原始值没有属性和方法
new String、new Boolen、new Number
	1.
	var num = 4;
	num.len = 3;
	//new Number(4).len = 3; delete 删除
	//new Number(4).len 重新生成
	console.log(num.len);//undefined
	2.
	var str = 'abcd';
	str.length = 2;
	//new String('abcd').length  delete 删除
	//new String('abcd').length 重新生成
	console.log(str); //abcd
	console.log(str.length) //4
	3.
	var str = 'abc';
	str += 1；
	var test = typeof str;
	if(test.length == 6) {
		test.sign = 'typeof返回的结果有可能是string';
		//new String('test').sign = XXX
	}
	//new String('test').sign = '';
	console.log(test.sign); // undefined	
************************原型*********************************
定义：
	原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。
	//Person.prototype --> 原型
	//Person.prototype = {} --> 祖先
	Person.prototype.name = 'hehe';
	function Person() {}
	var person = new Person();
	var person1 = new Person();
	console.log(person.name, person1.name);
	
	利用原型的特点和概念，可以提取公有属性
	Person.prototype.name = 'BMW';
	Person.prototype.width = 4900;
	Person.prototype.height = 1400;
	/*
	Person.prototype = {
		name: 'BMW',
		width: 4900,
		height: 1400
	}
	*/
	function Person(color) {
		/*
			var this = {
				__proto__: Person.prototype
			}
		*/
		this.color = color;
	}
	var person = new Person('red');
	
	1.
	Person.prototype.name = 'sunny';
	function Person () {}
	var person = new Person();
	Person.prorotype = {
		name: 'cherry'
	}
	console.log(person.name); //sunny
	/*
	var obj = { name: 'a' };
	var obj1 = obj;
	obj = { name: 'b' };
	console.log(obj1.name); //a
	Person.prorotype = {  name: 'a' };
	__proto__ = Person.prototype;
	Person.prototype = { name: 'b' };
	*/
	2.
	Person.prototype.name = 'sunny';
	function Person () {}
	Person.prorotype = {  
		name: 'cherry'
	}
	var person = new Person();
	console.log(person.name); //cherry

************************原型链*********************************
	eg:
	Person.prototype.name = 'abc';
	function Person () {
		/*
			var this = {
				__proto__: Person.prototype
			}
		*/
	}
	var obj = { name: 'sunny' };
	var person = new Person();
	Person.__proto__ = obj;
	console.log(person.name);//sunny


//Grand.prototype.__proto__ = Object.prototype;
Grand.prototype.lastName = 'Deng';
function Grand() {}
var grand = new Grand;
Father.prototype = grand;
function Father() {
	this.name = 'sunny';
	this.num = 100;
}
var father = new Father;
Son.prototype = father;
function Son() {
	this.hobbit = 'smoke';
}
var son = new Son();
son.num ++
console.log(father.name); //100;

//a.sayName() sayName里面的this指向是谁调用的这个方法，this就是指向谁
Person.prototype = {
	name: 'a',
	sayName: function() {
		console.log(this.name);
	}
}
function Person() {}
var person = new Person();
console.log(person.name); //a
修改如下：
Person.prototype = {
	name: 'a',
	sayName: function() {
		console.log(this.name);
	}
}
function Person() {
	this.name = 'b';
}
var person = new Person();
console.log(person.name); //b

Person.prototype = {
	height: 100
}
function Person() {
	this.eat = function() {
		this.height ++;
	}
}
var person = new Person();
console.log(person.height); //a

*******************Object.create**********************
//var obj = Object.create(原型)；

var obj = { name: 'sunny', age: '23' };
var obj1 = Object.create(obj);

Person.prototype.name = 'sunny';
function Person() {} 
var person = Object.create(Person.prototype);

绝大多数对象的最终都会继承自Object.prototype
特例：var obj = Object.create(null || 123); 

无toString： undefined.toString、 null.toString
123.toString 会识别成浮点型 

var num = 123;
//num.toString();  --> new Number(num).toString();
Number.prototype.toString = function() { }
//Number.prototype.__proto__ = Object.prototype;

//object.prototype.toString = function() {} (重写)
Person.prototype = {
	toString: function() {
		return : 'hehe';
	}
}
function Person() {}
var person = new Person();
console.log(person.toString()); //hehe
/*
	Object.prototype.toString
	Number.prototype.toString
	Array.prototype.toString
	Boolean.prototype.toString
	String.prototype.toString
*/
JS可正常计算的范围：小数点前16位，小数点后16位
**********************call、apply***************************
call、apply 改变this的指向

function Person(name, age) {
	//this == obj;
	//obj.name = name;
	//obj.name = name;
	this.name = 'sunny';
	this.age = '100';
}
var person = new Person('sunny', 100);
var obj = {}
Person.call(obj, 'cherry', 300);


function Person(name, age, sex) {
	this.name = name;
	this.age = age;
	this.sex = sex;
}
function Studen(name, age, sex, tel, grade) {
	Person.call(this, name, age, sex);
	this.tel = tel;
	this.grade = grade;
}
var student = new Student('sunny', 12, 'male', 138, 2018);


function Person(name, age, sex) {
	this.name = name;
	this.age = age;
	this.sex = sex;
}
function Studen(name, age, sex, tel, grade) {
	Person.apply(this, [name, age, sex]);
	this.tel = tel;
	this.grade = grade;
}
var student = new Student('sunny', 12, 'male', 138, 2018);

// call需要把实参按照形参的个数传进去
// apply 需要传一个arguments

javascript模式 0-35页上半部分或者50页，35页上半部分-38页上半部忽略

*******************继承**************************
原型链
	过多的继承了没用的属性
借用构造函数（call/apply）
	不能继承借用函数的原型
	每次构造函数都要多走一个函数
共享原型
	不能随便改动自己的原型 
	Person.prototype.lastName = 'sunny';
	function Person() {}
	function Son() {}
	Son.prototype = Person.protype;
	var son = new Son();
	console.log(son.lastName); //sunny

	function inherit(Target, Origin) {
		Target.protype = Origin.prototype;
	}
	inherit(Son, Person); (先继承后使用)
	var son = new Son();
	//inherit(Son, Person);
	console.log(son.lastName); //sunny
圣杯模式
	Fater.prototype.lastName = 'sunny';
	function Father(){}
	function Son(){}
	function inherit(Target, Origin){
		function F() {
			//Target.prototype = new F(); ***
			F.prototype = Origin.Prototype;
			Target.prototype = new F();     ***
			Target,prototype.constuctor = Target;
			Target.prototype.uber = Origin.prototype;
		}
	}
	/*
		var inherit = (function() {
			var F = function () {};
			return function (Target, Origin) {
				F.prototype = Origin.Prototype;
				Target.prototype = new F();    
				Target,prototype.constuctor = Target;
				Target.prototype.uber = Origin.prototype;
			}
		}())
	*/
	inherit(Son, Father);
	var son = new Son();
	var father = new Father();
	console.log(son.lastName); //sunny
	console.log(father.lastName); //sunny
	son.prototype.sex = 'male';
	console.log(son.sex); //male
	console.log(father.sex);//underfined
	son.__proto__ -->new F() --> Father.prototype

********************命名空间*********************
管理变量、防止污染全局、适用于模块化开发  
//var obj ={}
var name = 'cherry';
var init = (function() {
	var name = 'sunny';

	function callName() {
		console.log(name); //sunny
	}

	return function() {
		callName();
	}

}()) 
//通过闭包私有属性执行
init(); 
***********************链式********************
如何实现链式调用模式（模仿Jquery）
obj.eat().smoke().dirnk().sleep();

var obj = {
	eat: function() {
		console.log('Smoking');
		//return undefined; 默认
		return this;
	},
	drink: function() {
		console.log('Drinking');
		return this;
	},
	sleep: function() {
		console.log('Sleep');
		return this;
	}
}
obj.eat().drink().sleep();

var obj = ｛
	name: 'snuuy'
｝
隐形转换 obj.name --> obj['name']

********************对象枚举***************
for in 
	var obj = {
		name: 'sunny',
		age: 23
		//prop: 123
	}
	for(var prop in obj) {
		console.log(obj.prop); //undefind  看上面底层原理
		console.log(prop+' '+obj[prop]);
	}

hasOwnProperty

in

instance of





