/*
	一旦经历了var的操作，所得出来的属性，window，这种属性叫做不可配置的属性
	不可配置的属性delete不掉
*/
	eg:
	var num = 123;
	delete window.num //false

typef null => object
typeof NaN => number
true => 1
false => 0
Number([]); --> 0
***************************************
函数声明整体提升
变量 声明提升
imply global暗示全局变量
即任何变量，如果变量未经声明就赋值，此变量就为全局变量所有。
	a=10  ==> window.a=10;
一切声明的全局变量，全是window的属性
	var a=1; ==>window.a=1;
***************************************
预编译发生在函数执行前一刻
//预编译
创建AO对象  Activetion Object
找形参和变量声明，将变量和形参名作为AO属性名，值为：undefined
将实参值和形参统一
在函数体里面找函数声明，值赋予函数体
***********************函数***********************
function foo() {
	console.log(this)
}
foo.call() --> foo(); 

function fn(a) {
	console.log(a); //function a() {}
	
	var a=123;
	console.log(a) //123
	
	function a() {}
	console.log(a); //123
	
	var b=function() {}
	console.log(b); //function b() {}
	
	function d() {}
}
fn(1);

global object ===window === GO

//解析
function a() {
   function b() {
      function c() {}
      c();
   }
   b();
}
a();

a defined a.[[scope]] --> 0:GO
a doing a.[[scope]] --> 0:aAO
		   -->  1:GO
b defined b.[[scope]] --> 0:aAO
		   -->  1:GO		  
b doing b.[[scope]] --> 0:bAO
		   -->  1:aAO
		   -->  2:GO
c defined c.[[scope]] --> 0:bAO
		   -->  1:aAO
		   -->  2:GO	
c doing a.[[scope]] 0 -->cAO
		    1 --> bAO
		    2 --> cAO
		    3 --> GO
		
//闭包： （内部的函数被保存到外部时，将会生成闭包。闭包会导致原有作用域链不释放，造成内存泄漏。） 里面的函数比外面的函数活着还长 ^-^
function a() {
   function b() {
	var bbb=234;
	console.log(aaa);
   }
   var aaa=123;
   return b;
}
var glob=100;
var demo=a();
demo(); //123
***************************************
function a() {
  var num = 100;
  function b() {
	num ++;
	console.log(num);
  }
  return b;
}
var demo = a();
demo(); //101
demo(); //102
***************************************
function test() {
	var arr = [];
	for(var i = 0; i < 10; i++) {
		arr[i] = function() {
			console.log(i); // 打印10个10
		}
	}
	return arr;
}

var myArr = test();
for (var j = 0; j < 10; j++) {
	myArr[j]();
}
上面函数修改如下
function test() {
	var arr = [];
	for(var i = 0; i < 10; i++) {
		(function(j) {
			arr[j] = function() {
				console.log(j); //打印10个10
			}
		}(i))
	}
	return arr;
}

var demo = a;
function test() {
	var abc = 123;
	function a() {
		console.log(abc); //123
	}
	demo = a;
}
test();
demo();
***************************************
	a = 100;
	function demo(e) {
		function e() {}
		arguments[0] = 2;
		console.log(e); //2
		if(a) { //if里面不能放函数，之前可以放函数
			var b = 123;
			function c() {}
		}
		var c;
		a = 10;
		var a;
		console.log(b); //undefined
		f = 123;
		console.log(c); // undefined 或者 function c() {}
		console.log(a); //10
	}
	var a;
	demo(1);
	console.log(a); //100
	console.log(f); //123
***************************************
//立即执行函数 -> 执行完立即释放
	(function(a, b, c) { //形参
		console.log(a+b+c);
	}(1, 2, 3)); //实参

	var num = (function(a, b, c) { 
		 var d = a + b + c;
		 return d; //6
	}(1, 2, 3));

******只有表达式才能被执行符号执行******
	var test = function() {
		console.log('a'); //a
	}();
 
 	第二次执行 test(); //undefined;
*****************************************
 function test(a, b) {
 	console.log(a+b); // 什么也不输出
 }(1, 2);
 ***************************************
 （正负非）+|-|! function test() {
	console.log('a') //a
 }();
***************************************
逗号运算符：
a = (1 - 1, 1 + 1); //2 计算前面结果，再计算后面运算结果 => 返回后面结果

	var x = 1;
	if(function f() {}) { // 表达式, 再执行
		x += typeof f;
	}
	console.log(x); //1undefined
***********************对象************************
名词：函数引用、 函数执行()

对象创建方法： 
	字面量、
	var obj = {}
	构造函数（1:系统自带、2:自定义） 特点：大驼峰命名
	1:
	var obj = new Object{}
	2:
	function Person(color) {
		/*隐式
		var this = {
			name:'',
			height:''
			...
		}; 
		AO:{ this:{ name:... } }
		*/
		this.name = 'BMW';
		this.height = '1400';
		this.width = '4900';
		this.color = color;
		//显示 return {}; 返回空对象
		//显示 return 123; 返回这个对象里面的属性值 
		/*
		隐式 return this;
		*/
	}
	var person = new Person();
	内部原理：
		在函数体最前面隐式的加上this = {};
		执行this.xxx = xxx;
		隐式的返回this;
	
	Person.prototype.anme = 'sunny';
	function Person() {
		/*
		var this = {
			__proto__ : Person.prototype
		}
		*/
	}
	var person = new Person();
	
*****************包装类**************************
原始值没有属性和方法
new String、new Boolen、new Number
	1.
	var num = 4;
	num.len = 3;
	//new Number(4).len = 3; delete 删除
	//new Number(4).len 重新生成
	console.log(num.len);//undefined
	2.
	var str = 'abcd';
	str.length = 2;
	//new String('abcd').length  delete 删除
	//new String('abcd').length 重新生成
	console.log(str); //abcd
	console.log(str.length) //4
	3.
	var str = 'abc';
	str += 1；
	var test = typeof str;
	if(test.length == 6) {
		test.sign = 'typeof返回的结果有可能是string';
		//new String('test').sign = XXX
	}
	//new String('test').sign = '';
	console.log(test.sign); // undefined	
************************原型*********************************
定义：
	原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。
	//Person.prototype --> 原型
	//Person.prototype = {} --> 祖先
	Person.prototype.name = 'hehe';
	function Person() {}
	var person = new Person();
	var person1 = new Person();
	console.log(person.name, person1.name);
	
	利用原型的特点和概念，可以提取公有属性
	Person.prototype.name = 'BMW';
	Person.prototype.width = 4900;
	Person.prototype.height = 1400;
	/*
	Person.prototype = {
		name: 'BMW',
		width: 4900,
		height: 1400
	}
	*/
	function Person(color) {
		/*
			var this = {
				__proto__: Person.prototype
			}
		*/
		this.color = color;
	}
	var person = new Person('red');
	
	1.
	Person.prototype.name = 'sunny';
	function Person () {}
	var person = new Person();
	Person.prorotype = {
		name: 'cherry'
	}
	console.log(person.name); //sunny
	/*
	var obj = { name: 'a' };
	var obj1 = obj;
	obj = { name: 'b' };
	console.log(obj1.name); //a
	Person.prorotype = {  name: 'a' };
	__proto__ = Person.prototype;
	Person.prototype = { name: 'b' };
	*/
	2.
	Person.prototype.name = 'sunny';
	function Person () {}
	Person.prorotype = {  
		name: 'cherry'
	}
	var person = new Person();
	console.log(person.name); //cherry

************************原型链*********************************
	eg:
	Person.prototype.name = 'abc';
	function Person () {
		/*
			var this = {
				__proto__: Person.prototype
			}
		*/
	}
	var obj = { name: 'sunny' };
	var person = new Person();
	Person.__proto__ = obj;
	console.log(person.name);//sunny


//Grand.prototype.__proto__ = Object.prototype;
Grand.prototype.lastName = 'Deng';
function Grand() {}
var grand = new Grand;
Father.prototype = grand;
function Father() {
	this.name = 'sunny';
	this.num = 100;
}
var father = new Father;
Son.prototype = father;
function Son() {
	this.hobbit = 'smoke';
}
var son = new Son();
son.num ++
console.log(father.name); //100;

//a.sayName() sayName里面的this指向是谁调用的这个方法，this就是指向谁
Person.prototype = {
	name: 'a',
	sayName: function() {
		console.log(this.name);
	}
}
function Person() {}
var person = new Person();
console.log(person.name); //a
修改如下：
Person.prototype = {
	name: 'a',
	sayName: function() {
		console.log(this.name);
	}
}
function Person() {
	this.name = 'b';
}
var person = new Person();
console.log(person.name); //b

Person.prototype = {
	height: 100
}
function Person() {
	this.eat = function() {
		this.height ++;
	}
}
var person = new Person();
console.log(person.height); //a

*******************Object.create**********************
//var obj = Object.create(原型)；

var obj = { name: 'sunny', age: '23' };
var obj1 = Object.create(obj);

Person.prototype.name = 'sunny';
function Person() {} 
var person = Object.create(Person.prototype);

绝大多数对象的最终都会继承自Object.prototype
特例：var obj = Object.create(null || 123); 

无toString： undefined.toString、 null.toString
123.toString 会识别成浮点型 

var num = 123;
//num.toString();  --> new Number(num).toString();
Number.prototype.toString = function() { }
//Number.prototype.__proto__ = Object.prototype;

//object.prototype.toString = function() {} (重写)
Person.prototype = {
	toString: function() {
		return : 'hehe';
	}
}
function Person() {}
var person = new Person();
console.log(person.toString()); //hehe
/*
	Object.prototype.toString
	Number.prototype.toString
	Array.prototype.toString
	Boolean.prototype.toString
	String.prototype.toString
*/
JS可正常计算的范围：小数点前16位，小数点后16位
**********************call、apply***************************
call、apply 改变this的指向

function Person(name, age) {
	//this == obj;
	//obj.name = name;
	//obj.name = name;
	this.name = 'sunny';
	this.age = '100';
}
var person = new Person('sunny', 100);
var obj = {}
Person.call(obj, 'cherry', 300);


function Person(name, age, sex) {
	this.name = name;
	this.age = age;
	this.sex = sex;
}
function Studen(name, age, sex, tel, grade) {
	Person.call(this, name, age, sex);
	this.tel = tel;
	this.grade = grade;
}
var student = new Student('sunny', 12, 'male', 138, 2018);


function Person(name, age, sex) {
	this.name = name;
	this.age = age;
	this.sex = sex;
}
function Studen(name, age, sex, tel, grade) {
	Person.apply(this, [name, age, sex]);
	this.tel = tel;
	this.grade = grade;
}
var student = new Student('sunny', 12, 'male', 138, 2018);

// call需要把实参按照形参的个数传进去
// apply 需要传一个arguments

function foo() {
	bar.apply(null, arguments); 
}
function bar() {
	console.log(arguments); //1, 2, 3, 4, 5
}
foo(1, 2, 3, 4, 5);
javascript设计模式 0-35页上半部分或者50页，35页上半部分-38页上半部忽略

*******************继承**************************
原型链
	过多的继承了没用的属性
借用构造函数（call/apply）
	不能继承借用函数的原型
	每次构造函数都要多走一个函数
共享原型
	不能随便改动自己的原型 
	Person.prototype.lastName = 'sunny';
	function Person() {}
	function Son() {}
	Son.prototype = Person.protype;
	var son = new Son();
	console.log(son.lastName); //sunny

	function inherit(Target, Origin) {
		Target.protype = Origin.prototype;
	}
	inherit(Son, Person); (先继承后使用)
	var son = new Son();
	//inherit(Son, Person);
	console.log(son.lastName); //sunny
圣杯模式
	Fater.prototype.lastName = 'sunny';
	function Father(){}
	function Son(){}
	function inherit(Target, Origin){
		function F() {
			//Target.prototype = new F(); ***
			F.prototype = Origin.Prototype;
			Target.prototype = new F();     ***
			Target.prototype.constuctor = Target;
			Target.prototype.uber = Origin.prototype;
		}
	}
	/*
		var inherit = (function() {
			var F = function () {};
			return function (Target, Origin) {
				F.prototype = Origin.Prototype;
				Target.prototype = new F();    
				Target.prototype.constuctor = Target;
				Target.prototype.uber = Origin.prototype;
			}
		}())
	*/
	inherit(Son, Father);
	var son = new Son();
	var father = new Father();
	console.log(son.lastName); //sunny
	console.log(father.lastName); //sunny
	son.prototype.sex = 'male';
	console.log(son.sex); //male
	console.log(father.sex);//underfined
	son.__proto__ -->new F() --> Father.prototype

********************命名空间*********************
管理变量、防止污染全局、适用于模块化开发  
//var obj ={}
var name = 'cherry';
var init = (function() {
	var name = 'sunny';
	function callName() {
		console.log(name); //sunny
	}
	return function() {
		callName();
	}
}()) 
//通过闭包私有属性执行(外部不能直接访问name值，只能callName函数能访问)
init(); 
***********************链式********************
如何实现链式调用模式（模仿Jquery）
obj.eat().smoke().dirnk().sleep();

var obj = {
	eat: function() {
		console.log('Smoking');
		//return undefined; 默认
		return this;
	},
	drink: function() {
		console.log('Drinking');
		return this;
	},
	sleep: function() {
		console.log('Sleep');
		return this;
	}
}
obj.eat().drink().sleep();

var obj = ｛
	name: 'snuuy'
｝
隐形转换 obj.name --> obj['name']

********************对象枚举***************
for in 
	var obj = {
		name: 'sunny',
		age: 23
		//prop: 123
	}
	for(var prop in obj) {
		console.log(obj.prop); //undefind  看上面底层原理
		console.log(prop+' '+obj[prop]);
	}

hasOwnProperty
	var obj = {
		name: 'sunny',
		age: 23,
		__proto__: {
			lastName: 'cherry',
			__proto__: Object.prototype
		}
	}
	obj.prototype.name = '123';
	for(var prop in obj) {
		//只有是对象就用hasOwnProperty
		//是自己的属性返回true，否则返回false
		//能返回原型及原型链上的属性，一旦延展到原型链最顶端(系统自带的不会打印、自己设置的会打印)就不会打印这个属性
		if(obj.hasOwnProperty(prop)) {  
			console.log(obj[prop]);
		}
	}

in 能不能访问这个对象的属性，包括原型
	var obj = {
		name: 'sunny',
		age: 23,
		__proto__: {
			lastName: 'cherry',
			__proto__: Object.prototype
		}
	}
	'height' in obj  //true
	'lastName' in  obj //true

instanceof 
	// A instanceof B
	//A对象是不是B构造函数构造出来的 （官方解释）
	//看A对象的原型上  有没有 B的原型 ***
	//call、toString
	function Person() {}
	var person = new Person();
	var obj = {};
	person instaceof Person //true
	person instanceof Object //true
	[] instanceof Object //true
	[] instanceof Array //true
	obj instanceof Person //false

	//Object.prototype.toString.call([]);
	Object.prototype.toString = function() {
		//this 谁调用指向谁
		//识别this
		//返回相应的结果
	}
	区分数组对象的方法  constructor instanceof toString

	浅度克隆、深度克隆
	var obj = {
		name: 'sunny',
		age: '23',
		sex: 'female'
	}
	var obj1 = {}
	function clone(origin, target) {
		var target = target || {};
		for(var prop in origin) {
			target[prop] = origin[prop];
		}
		retrun target;
	}
	clone(obj, obj1);


	var obj = {
		name: 'sunny',
		age: '23',
		sex: 'female',
		card: ['BMW', 'visa'],
		wife: {
			name: 'cherry',
			son: {
				name: 'abc'
			}
		}
	}
	var obj1 = {}
	/*	
		遍历数组 用for in
		判断是不是原始值 用typeof
		判断是数组还是对象 用toString.call/constructor/instanceof
		建立相应的数组或对象 
	*/
	function deepClone(origin, target) {
		var target = target || {},
		toStr = Object.prototype.toString,
		arrStr = '[object Array]';
		for(var prop in origin) {
			if(origin.hasOwnProperty(prop)) {
				if(origin[prop] !== 'null' && typeof(origin[prop]) == 'object') { //引用值
					if(toStr.call(oringin[prop] == arrStr)) {
						target[prop] = [];
					}else{
						target[prop] = {};
					}
					//target[prop] = toStr.call(oringin[prop] == arrStr ? [] : {};
					deepCLone(origin[prop], target[prop]);
				}else{
					target[prop] = oringin[prop];
				}
			}
		}
		retrun target;
	}
	deepClone(obj, obj1);

三目运算符
	//条件判断 ？ 是 ： 否 并且会返回值
	var num = 1 > 0 ? ('10' > '9' ? 1 : 0) : 2; //0
***************************this***************************
检测是否属于isNaN
function myIsNaN(num) {
	var ret = Number(num);
	ret += '';
	if(ret == 'NaN') {
		retrun true;
	}else{
		return false;
	}
}

{} == {} //false


this:
	1、函数预编译过程中this -> window
	2、全局作用域里this -> window
	3、call/apply可以改变函数运行时this指向
	4、obj.func(); func()里面的this指向obj (谁调用了这个方法，this就指向谁)

	function foo(x) {
		var a = 123;
		function b() {}
	}
	foo(1);

	OA: {
		arguments: [1],
		this: window,
		a: undefined,
		b:  function b() {}
	}


	var name = '222';
	var a = {
		name: '111',
		say: function() {
			console.log(this.name);
		}
	}
	var fun = a.say;
	fun();  //222
	a.say(); //111
	var b = {
		name: '333',
		say: function(fun) {
			//this --> b
			/*
			function() {
				console.log(this.name); 
				//this --> window
			}
			*/
			fun();
		}
	}
	b.say(a.say); //222
	b.say = a.say;
	b.say(); //333

	var foo = '123';
	function print() {
		var foo = '456';
		this.foo = '789';
		console.log(foo); //456
	}
	print();

	var foo = 123;
	fuunction print() {
		this.foo = 234;
		console.log(foo); 
	}
	print(); //234
	new Print(); //123

	var a = 5;
	function test()  {
		a = 0;
		console.log(a);
		alert(this.a);
		var a;
		alert(a);
	}
	//test();   // 0 5 0
	new test(); // 0 undefined 0

	function print() {
		console.log(foo); //undefined
		var foo = 2;
		console.log(foo); //2
		alert(hello); // hello is not undefined
	}
	print();

	function print() {
		var test;
		test();
		function test(){
			console.log(1); //1
		}
	}
	print();

	function print() {
		var x = 1;
		if(x =='1') console.log(x); //true
		if(x === '1') console.log(x); //false
	}
	print();

	function print() {
		var marty = {
			name: 'marty',
			printName: function() {
				console.log(this.name);
			}
		}
		var test1 = { name: 'test1' };
		var test2 = { name:'test2' };
		var test3 = { name: 'test3'};
		test3.printName = marty.printName;
		var printName2 = marty.printName.bind({ name: 123});
		marty.printName.call(test1); //test1
		marty.printName.apply(test2); //test2
		marty.printName(); //marty
		printName2();
		test3.printName(); //test3
	}
	print();

	var bar = { a: '002'};
	function print() {
		bar.a = 'a';
		Object.prototype.b = 'b';
		return function inner() {
			alert(bar.a); //a
			alert(bar.b); //b
		}
	}
	print()();


arguments.calee （运行时的函数）
	function foo() {
		console.log(arguments.calee);
		console.log(arguments.calee == foo); //true
	}
	foo();


	var num  = (function(n) {
		if(n ==1) {
			return 1;
		}
		return n * arguments.callee(n - 1);
	} (20))

	function foo() {
		console.log(arguments.calee); //foo函数
		function test() {
			console.log(arguments.calee); //test函数
		}
		tes();
	}
	foo();
func.caller （函数自己的属性）
	function test() {
		console.log(test.caller); //test函数
	}
	test();

*********************数组*****************************
var arr = [1, 2, 3];
Array.toSTring.push = function() {
	for(var i = 0; i < arguments.length; i++) {
		this[this.length] = arguments[i];
	}
	return this.length;
}
改变原数组：
	push(4, 4, 5)//向数组最后一位添加
	pop() //从最后一位开始拿出去
	shift() //从数组前面删除
	unshift(-1, 0) //在数组前面添加
	reverse() //逆转数组
	sort//排序
	splice(从第几位开始, 截取多少长度, 在切口处添加新的数据)
 
	slice = function (pos) {
		pos += pos > 0 ? 0 : this.length;
	}

	/*
		必须写俩形参
		返回值 
			1、当返回值为负数，那么前面的数放在前面
			2、为正数，那么后面的数在前
			3、为0，不动
	*/
	var arr = [1, 3, 5, 4, 10];
	arr.sort(function(a, b) {
		/*
		if(a > b) {  a - b > 0
			return 1;
		}else{ a - b < 0
			return -1;
		}
		*/
		return a - b;  //升序
		//return b -a; 降序
	})

	给一个有序的数组 乱序
	var arr = [1, 2, 3, 4, 5, 6];
	arr.sort(function(){
		return Math.random() - 0.5;
	})


不改变原数组
	concat join  --> split toString slice
	var arr = [1, 2, 3, 4, 5, 6];
	//slice(从该位开始截，截取到该位)
	slice(1, 3); //2, 3
   join() //返回数组
   split()// 返回字符串

*********************类数组****************************
类数组必须有length属性(能像数组/对象一样使用)
function foo() {
	console.log(arguments);
	//arguments.push(7);
}
foo(1, 2, 3, 4, 5);

var obj = {
	'0': 'a',
	'1': 'b',
	'3': 'c',
	'length': 3,
	'push': Array.prototype.push,
	'splice': Array.prototype.splice
}

var arr = ['a', 'b', 'c']

obj.push('d'); //打印...


/*
	属性要为索引(数字)属性，必须有length属性，最好加上push
	好处：

	Array.prototype.push = function(target) {
		this.[obj.length] = target;
		this.length ++;
	}

*/

var obj = {
	'2': 'a',
	'3': 'b',
	'lenght': 2,
	'push': Array.prototype.push
}
obj.push('c');
obj.push('d');
//打印obj...
obj = {
	2: 'c',
	3: 'd',
	length: 4
}

封装type
	/*
		typeof([]) --> array
		typeof({}) --> object
		typeof(123) --> nubmer
		typeof(function) --> object
		typeof(new Number) --> new Object
		1、分类：原始值(没有属性,能访问) 引用值
		2、区分引用值
	*/

	function type(target) {
		var template = {
			'[object Array]' : 'array',
			'[object Object]' : 'object',
			'[object Number]' : 'number - object',
			'[object Bollean]' : 'boolean - object',
			'[object String]' : 'string - object'
		}
		if(target === null) {
			return 'null';
		}
		if(typeof(target) == 'object'){
			var str = Object.prototype.toString.call(target);
			return template[str];
		}else{
			return typeof(target);
		}
	}
数组去重
	/* 
		利用对象的属性不能重复特征
	*/
	var arr = [1, 1, 1, 1, 2, 2, 2];
	Array.prototype.unique = function() {
		var temp = {},
			arr = [],
			len = this.length;
		for(var i = 0; i < len; i++) {
			if(!temp[this[i]]) { //取值undefined
				temp[this[i]] = 1; //随意等于一个值 处理0 undefined
				arr.push([this[i]]);
			}
		}
		return arr;
	}

...
***************DOM、BOM****************
...


