## 跨域
跨域在不属于同源策略形式下进行的，所谓同源策略包括(域名、协议、端口号)；只要域名、协议、端口号任意一个不同属于跨域。
* 严格说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域读操作。

通常浏览器允许进行跨域写操作(cross-origin writes)，比如：链接

通常浏览器允许进行跨域资源嵌入(cross-origin embedding)，如：script

通常浏览器不允许跨域读操作(corss-origin reads)。

由此得出结论：cookie允许跨域吗？

## 跨域的方法

* JSONP：动态创建script标签插入body中，编写一个回调函数，在远程服务器调用该函数并且参数以JSON数据格式进行传参。

```
	//客户端
	function cbFn(data) {
		//...
	}

	//动态插入body中
	<script src="http://xxx.com?cbFn=cbFn"></script>

```

```
	//服务器
	...
	cbFn({name: 'JSONP'});
	...

```

* CORS：根据请求内容不同，浏览器会需要添加对应的header或者发起额外的请求。

	简单过程：
	* 浏览器发送请求，判断是否属于同源策略；
	* 若不属于，则会在头部添加origin属性标识(这个标识后端会提前在代码中添加，等到浏览器发送请求时，会自动在头部添加该标识)；
	* 有了该标识就允许跨域请求。

## 安全 
* XXS：相对于前端进行一些界面文本校验操作
如： 在登录时候，文本框输入的是一段获取用户信息cookie。[ http://xxx.com/+'console.log(document.cookie)' ]

防御措施：
* 表单数据特殊字符进行转义，如： > -> >
* 插入html代码，后端尽量输出转以后的代码，前端再进行转义html代码。



CSRF 跨站伪造请求
如： 网站页面底部有个弹窗，表面看着和真实的没有任何区别，只是跳转地址不同；点击进入到钓鱼网站，劫持获取用户信息。

防御措施：
* 验证 HTTP Referer 字段 -> 记录了该HTTP请求的来源地址
* 采用token进行校验
* Set-Cookie响应头新增SameSite属性，它用来标明这个 cookie是个“同站cookie”，同站cookie只能作为第一方cookie，不能作为第三方cookie。SameSite有两个属性值，分别是Strict和Lax。
