NodeJS特点
	单线程
	非阻塞I/O  Non-blocking 
	事件驱动   Event Driven
	Node不为每个用户开辟一个线程, 所以选择了单线程。单线程, 要照顾所有的用户, 就必须有非阻塞I/O, 否则一个人的I/O就把别人
	,一旦有非阻塞I/O, 一个人如果I/O去了, 就会放弃CPU的使用权, 换成另一个人使用CPU, 所以CPU的利用率100%。第一个人I/O结束
	.就要用事件来通知线程, 此时必须有事件环, 就有一个队伍调度机制。Node中有超过半数的C++代码, 在搭建事件环。

	<!--（回调函数嵌套回调函数）-->
NodeJS适合开发什么样的应用程序？
	善于I/O, 不善于计算; 因为NodeJS最擅长就是任务调度

	当应用程序需要处理大量并发的I/O, 而在向客户端发出相应之前, 应用程序内部并不需要进行非常复杂的处理的时候, NodeJS非常适合。 
	NodeJS也非常适合与web socket配合, 开发长链接的实时交互应用程序。
	比如： 用户表单收集、考试系统、聊天室、图文直播、提供JSON的API(为前台Angular使用)

第一个运行包
	// require引包
	var http = require("http");
	var fs = require('fs');
	//创建服务器 参数是一个回调函数, 表示如果有请求进来, 要做什么
	var server = http.createServer(function(req, res) {
		//req表示请求, request; res表示相应response

		if(req.url == '/favicon.ico') return;

		if(req.url == "/fang") {
			fs.readFile("./test.html", function(err, data) { //读取html内容
				//第一个参数是完整路径, 当前目录 /
				//第二个参数, 就是回调函数, 表示文件读取成功之后, 做的事情
				//设置HTTP头部, 状态码是200, 文件类型是html, 字符集是utf-8
				res.writeHead(200, {"Content-type":"text/html;charset=UTF-8"});
				//res.end("我买了一个iPhone"+(1+2+3)+'s');
				res.write(data);
				res.end(data); //必须写; end里面不能直接写成1+2
				//res.end((1+2).toString());

				/*
					if(error) {
						throw err;
					}

					//fs模块 ------------

					//stat检测状态 (path, callback)
					fs.stat('./a/b', function(err, stats) { 
						//检测这个路径是不是一个文件夹 是文件夹返回true, 否则返回false
						console.log(stats.isDirectory());
					});

					//使用数组进行遍历获取文件或文件夹
					fs.readir('./a/', function(err, files) {
						//files是个数组, 表示a文件下所有的东西, 包括文件及文件夹
						console.log(files);
						var wenjianjia = [];
						(function fn(i){
							if(i == files.length) return; //遍历结束
							fs.atat('./a/' + files[i], function() {
								if(stats.isDirectory()) {
									wenjianjia.push(files[i]);
								}
								fn(i+1);
							});
						}(0))
					});
					res.end(data);
				*/
				console.log(1);
			})
			console.log(2); 
		}else if(req.url == "yuan") {
			fs.readFile("./yuan.html", function(err, data) {
				res.writeHead(200, {"Content-type":"text/html;charset=UTF-8"});
				res.end(data);
			})
		}else if(req.url == "b.css") { // link中的css名字
			fs.readFile("./a.css", function(err, data) { //写css的文件名字
				res.writeHead(200, {"Content-type":"text/css"});
				res.end(data);
			})
		}else if(req.url == "0.jpg") {
			fs.readFile("./0.jpg", function(err, data) {
				res.writeHead(200, {"Content-type":"image/jpg"});
				res.end(data);
			})
		}else{
			res.writeHead(400, {"Content-type":"text/html;charset=UTF-8"});
			res.end("没有此界面");
		}
	});
	//运行服务器 监听3000端口(端口号可以任意修改)
	server.listen(3000, "127.0.0.1");
	//浏览器访问:127.0.0.1:3000
 	//NodeJS是服务器的程序, 写的js语句, 都将运行在服务器上, 返回给客户的, 都是已经处理好的纯html
url:
 	URL和真是物理文件是没有关系。URL通过Node的顶层路由设计, 呈现一个静态文件。
 
 	var http = require("http");
 	var url = require('url');  127.0.0.1:3000/a/b?id=1&age=2;
 	http.createServer(function(req, res) {
 		var path = url.parse(req.url).pathname; /a/b
 		//var query = url.parse(req.url).query;  //id=1
 		//var query = url.parse(req.url, true).query; //成对存在{id:1, age:2} 
 		//url.path()如果第二个参数是true, 那么就可以将会所有的查询变成对
 		//就可以直接打点得到这个参数
 		console.log(query);
 		console.log(path);

 		/* 静态服务器
 		var extname = path.extname(pathname);
		var fileUrl =  './' + path.normalize('./static/' + path);
 		fs.readFile('./static/' + path, function(err, data) {
 			if(err) {
 				//如果此文件不存在, 应该用404
 				fs.readFile('./static/404.html', function(err, data) {
 					res.writeHead(200, {"Content-type":"text/html;charset=UTF-8"});
 					res.end(data);
 				})
 			}
 			//HTML类型, text/html
 			//jpg文件 image/jpg
 			var mime = getMine(extname);
 			res.writeHead(200, {'Content-type':mime});
 			res.end(data);
			/*
			getMine(extname, function(mime) {
 				res.writeHead(200, {'Content-type':mime});
 				res.end(data);	
			});
			*/
 		})

 		*/
 		res.end();
 	}).listen(300, 'localhost');

 	function getMine(extname) {
		//读取文件 抛出错误 
		/*
		fs.readFile('./mine.json', function(err, data) {
			if(err) {
				return;
			}
			var minJSON = JSON.parse(data);
			var mine = mineJSON[extname] || 'text/plain';
			callback(mine);
		})
		*/
 		switch(extname){
 			case: '.html':
 				return "text/html";
 				break;
 			case: '.jpg':
 				return "image/jpg";
 				break;
 			case: '.css':
 				return 'text/css';
 				break;
 		}
 	}
	

模块的概念
	//每各模块都是独立的文件, 文件中的函数, 变量在这个JS文件中生效, 外部文件不能访问
	//使用exports进行暴露, 提供外部使用
	//exports可以多次, require只需一次
	a.js
		var msg = 'sunny';
		exports.msg = msg;
	b.js
		var A = reuqire('./a.js'); //如果不写./, 默认从node_modules中读取
		console.log(A.msg);
	

	function Person(name, age) {
		this.name = name;
		this.age = age;
	}
	Person.prototype = {
		say: function() {
			console.log(this.name);
		}
	}
	//Person被视为构造函数, 可以用new实例化
	module.exports = Person;

	var Person = require('./Person.js');
	var sunny = new Person('sunny', 18);
	sunny.say(); //'sunny'

	//某一文件中, 提供了函数, 共别人使用, 只需要暴露函数就行。 exports.xxx = xxx;
	//某一文件中, 描述了一个类。 module.exports = xxx;

	//	./都不写从main文件中读取
	//如果node_modules中没有index.js文件，推荐使用package.json文件
	//package.json  存在模块文件夹根目录(与exports文件同级)
		{
			name: '',
			version: '0.0.1',
			main: '' //入口文件
		}
	
路径
	//a要引用b;
		var b = require('./b.js');
	//b要引用c
		var b = require('./c.js');
	//但是, fs等其他的模块用到路径的时候, 都是相当于cmd命令光标所在位置
	//所以, 在b中想读1.txt文件, 推荐绝对路径
	fs.readFile(__dirname + '/1.txt', function(err, data) {
		if(err) { throw error; }
		console.log(data);
	});

